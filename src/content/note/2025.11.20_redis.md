---
title: Redis
description: 这是一篇详细介绍Redis的博文
publishDate: 2025-11-20T10:24
---

单机MySQL每秒可以处理2000-4000个请求

Redis 每秒11w次，写 8w次

redis为什么快
1. 基于内存
2. 单线程
redis的常见数据结构
1. string
2. hash
3. list
4. set
5. zset

**redis 的安全性**

设置密码 也就是在 redis.conf文件中设置requirepass的值

**Redis的事务**

Redis中的事务其实类似于批量操作，使用MULTI 开启一个事务
然后执行命令，只有在触发EXEC的时候才会批量开始执行这些命令，在这个过程中如果有其他外部的命令触发，则需要在当前批量命令执行完后再执行，事务的特点：
1. 无法回滚，碰到错误前面执行过的命令无法回滚
2. 不会终止，碰到错误后面的命令也会正常执行。

**Redis持久化**

1. RDB持久化（Redis Database）

- 在指定时间间隔内，将内存中整个数据集的快照二进制压缩文件保存到磁盘（默认文件为dump.rdb
- 优点是：体积小，回复速度快，并且持久化的过程是父进程fork的子线程执行，不影响其他命令的执行
- 缺点：会丢失最后一次快照之后的所有数据
2. AOF（Append Only File）
- 记录服务器运行期间所有的写命令，并在服务启动的时候重新执行这些命令来重建原始数据集。
- 优点：数据安全性小，配置合适的同步策略，最多只会丢失1s的数据，AOF文件是一个只追加的日志，即使文件末尾有损坏，也很容易修复。
- 缺点：体积大，写负载高的情况下，对性能影响大，回复速度慢
- AOF模式下的AOF重写，是遍历redis的所有key，对每个key向AOF中添加一条能够重建这个key的命令。
3. 混合持久化
- AOF重写时，会将当前内存数据快照和重写期间产生的增量AOF日志一起写入一个新的AOF文件中。
  - 流程：触发AOF重写：，当AOF文件大小增加到一定比例时（通过auto-aof-rewrite-percentage 和 auto-aof-rewrite-min-size 配置），或者手动执行BGREWRITEAOF 命令时，重写过程触发。
  - Fork子进程：Redis主进程会fork一个子进程来进行重写工作，类似bgsave 
写入RDB到AOF：子进程写入RDB到新的临时AOF文件中，然后在写的这个过程中主进程会继续处理客户端的命令，这些新命令不仅会写到现有的AOF文件中，还会被缓存到内存中的一个缓冲区里
  - 写入增量AOF：RDB写完后，会从主进程获取内存缓存区中的增量写命令，这些命令以AOF格式追加到刚刚的RDB文件后面。
当子进程完成新的AOF文件的写入后，会用这个新的混合AOF文件替换原有的AOF文件。

**内存淘汰机制**

围绕着三种策略
- LRU
- LFU
- random

然后区分为两类

第一类是设置了过期时间的
- volatile-lru
- volatile-lfu
- volatile-ttl
- volatile-random

第二类是没有设置过期时间的
- allkeys-lru
- allkeys-lfu
- allkeys-random最后就是不淘汰
- noenviction：最终会写错误，读正常

**LRU底层实现：**

redis底层实现的是一种近似LRU的算法，每次随机选用N（maxmemory-samples )个数据进行LRU淘汰，比较这批数据的lru字段，把lru最小的淘汰出去，以后再次进行数据淘汰时，会以第一次淘汰时创建的候选集中最小lru的值为基准，挑选lru字段值小于 minLruInSet 的数据放入到集合中，当候选数据集中的数据个数再次达到maxmemory-samples 时，Redis就把候选集合中的lru字段值最小的数据淘汰出去。通过维护这个 lru 小值集合可以减小发生数据淘汰时对 redis 产生的性能影响，因为它不需要使用链表来保存所有的数据，也不存在数据的移动。当N=10的时候，性能接近真正的LRU标准实现

**过期Key的处理**

- 惰性删除：当访问key的时候采取判断是否过期，如果过期就删掉，但是会造成内存浪费
- 定时删除：设置key的过期时间的同时，创建一个定时器，当到达过期时间点，立即执行对key的删除操作，会浪费cpu
- 定期删除：隔一段时间，就对数据检查一次，删除过期的key
redis使用的是惰性删除+定期删除两种策略
- 惰性删除：访问时
- 定期删除：一般每秒执行十次，由redis的定时任务serverCron 驱动，每次会依次检查各个数据库，从当前数据库的 expires 字典中随机抽取一定数量的 Key（默认是 20 个）。对这 20 个 Key 逐一检查，删除其中所有已过期的 Key。如果本轮抽查中，已过期 Key 的数量超过了抽查数的 25%（即 5 个），说明这个数据库里可能还有很多过期 Key。那么，Redis 会立即重复这个“随机抽查-删除”的过程，直到已过期 Key 的比例低于 25%，或者本次定期删除的总耗时已经超过了 25ms 的时间限制。
  - 25% 规则：防止在有过大量过期 Key 的数据库上无限循环。
  - 25ms 时间限制：保证定期删除不会过度占用主线程，影响正常命令处理。

**Redis主从复制**

流程：
- 开始同步：从节点通过像主节点发送 PSYNC 命令发起同步
- 全量复制：如果是第一次连接或之前的连接失效，从节点会请求全量复制，主节点将当前数据快照（RDB文件）发送给从节点
- 增量复制：全量复制完，主从节点之间会保持一个长连接，主节点会通过这个连接将后续的写操作传递给从节点执行，来保证数据的一致。

